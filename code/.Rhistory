p + geom_point()
csupports
ssupports
D_all
ssupports <- mapply(function(x,y) get_node_support(x, y, threshold=-1), x=true_trees,y=synth)
D_all = data.frame(unlist(csupports), unlist(ssupports))
p_all <- ggplot(D_all, aes(unlist(csupports), unlist(ssupports)))
p_all + geom_point()
synth
ssupports <- mapply(function(x,y) get_node_support(x, y, threshold=-1), x=true_trees,y=synth)
synth[[1]]
synth[[1]][[1]]
synth[[1]][[2]]
synth[[2]][[2]]
synth[[2]][[1]]
synth[[3]][[1]]
synth[[4]][[1]]
synth[[5]][[1]]
readsynthetic <- function(tree) {
keep = (grepl("hmmsearch2-sample2",tree$tip.label, perl=TRUE))
tree <- drop.tip(tree, which(!keep))
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multisynthetic <- function( trees ){
ntrees<-lapply(trees, readsynthetic)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
synthetic_boot <- multisynthetic( read.tree("run1/RAxML_bootstrap.synthetic-10") )
synthetic_boot
synthetic_boot[[1]]
synth <- lapply(i, function(x) multisynthetic(read.tree(paste0("run",x,"/RAxML_bootstrap.synthetic-10"))))
synth[[1]][[1]]
synth[[2]][[1]]
synth[[3]][[1]]
ssupports <- mapply(function(x,y) get_node_support(x, y, threshold=-1), x=true_trees,y=synth)
D_all = data.frame(unlist(csupports), unlist(ssupports))
p_all <- ggplot(D_all, aes(unlist(csupports), unlist(ssupports)))
p_all + geom_point()
D_all
phy
treeset
treeset[[1]]
clades = prop.clades(phy, treeset) / length(treeset)
prop.part(phy)
prop.part(treeset)
clades = prop.clades(phy, treeset) / length(treeset)
clades = prop.clades(phy, treeset)
length(treeset)
prop.part(phy)
p_all + geom_point() + coord_equal
p_all + geom_point() + coord_equal()
p_all + geom_point() + coord_equal + xlab("consensus supports") + ylab("synthetic supports")
p_all + geom_point() + coord_equal() + xlab("consensus supports") + ylab("synthetic supports")
D_all
library(dplyr)
head(D_all)
library(dplyr, unlist.csupports. != NA, unlist.ssupports. != NA)
filter(D_all, unlist.csupports. != NA, unlist.ssupports. != NA)
filter(D_all, unlist.csupports. != NA)
filter(D_all, unlist.csupports != NA)
filter(D_all, !is.NA(unlist.csupports.))
filter(D_all, !is.na(unlist.csupports.))
nrow(filter(D_all, !is.na(unlist.csupports.)))
library(ape)
library(ggtree)
library(hutan)
knitr::opts_knit$set(root.dir = "~/Dropbox-Brown/BlueWaters/R04")
knitr::opts_chunk$set(echo = TRUE)
get_node_support <- function(  tree, treeset, threshold=70 ){
l1 <- length(tree$tip.label)
l2 <- length(treeset[[1]]$tip.label)
if(l1==l2) {
# Returns a vector corresponding to nodes in tree, with percent of trees
# in treeset that contain the corresponding bipartition
clades = prop.clades(tree, treeset) / length(treeset)
nodes = c(rep(NA,length(tree$tip.label)), round(clades*100)) # Offset with NA values for tips
nodes[ length(tree$tip.label) + 1 ] = NA # Set the root value to NA, not a robust way to find root but works in this case
nodes[ nodes < threshold  ] = NA
}
else {
nodes = c(NA)
}
return(nodes)
}
tree_support <- function(tree, treeset) {
len <- length(treeset)
boot <- c(tree, treeset)
class(boot) <- "multiPhylo"
boot<-.compressTipLabel(boot)
support_true <- prop.part(boot[1])
support_boots <- prop.part(boot[2:len+1])
index <- match(support_boots, support_true)
#(attr(sup2, "number")/len2)[i3]
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
compare_support <- function(boot1, boot2) {
len1 <- length(boot1)
len2 <- length(boot2)
boot <- c(boot1, boot2)
class(boot) <- "multiPhylo"
boot <- .compressTipLabel(boot)
support  <- prop.part(boot)
support1 <- prop.part(boot[1:len1])
support2 <- prop.part(boot[len1+1:len2])
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
readnames <- function(  tree  ){
# simplifies taxon names to just numbers rather than reads
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multireadnames <- function( trees ){
ntrees<-lapply(trees, readnames)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
readsynthetic <- function(tree) {
keep = (grepl("hmmsearch2-sample2",tree$tip.label, perl=TRUE))
tree <- drop.tip(tree, which(!keep))
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multisynthetic <- function( trees ){
ntrees<-lapply(trees, readsynthetic)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
setwd("~/Dropbox-Brown/BlueWaters/R04")
true_tree9 <- read.tree("run9/simulated_tree.tre")
consensus_boot9 <- multireadnames( read.tree("run9/RAxML_bootstrap.consensus") )
synthetic_boot9 <- multisynthetic( read.tree("run9/RAxML_bootstrap.synthetic-10") )
cs9 = get_node_support(true_tree9, consensus_boot9, threshold=-1)
ss9 = get_node_support(true_tree9, synthetic_boot9, threshold=-1)
ggtree(true_tree9, branch.length='none') +
geom_text(aes(label=cs9), vjust=-.5, hjust=2, size=2, col="red") +
geom_text(aes(label=ss9), vjust=1.5, hjust=2, size=2, col="blue") +
geom_tiplab(size=2.5) +
xlim(NA, 15)
D = data.frame(cs9, ss9)
p <- ggplot(D, aes(cs9, ss9))
p + geom_point()
true_tree8 <- read.tree("run8/simulated_tree.tre")
consensus_boot8 <- multireadnames( read.tree("run8/RAxML_bootstrap.consensus") )
synthetic_boot8 <- multisynthetic( read.tree("run8/RAxML_bootstrap.synthetic-10") )
cs8 = get_node_support(true_tree8, consensus_boot8, threshold=-1)
ss8 = get_node_support(true_tree8, synthetic_boot8, threshold=-1)
ggtree(true_tree8, branch.length='none') +
geom_text(aes(label=cs8), vjust=-.5, hjust=2, size=2, col="red") +
geom_text(aes(label=ss8), vjust=1.5, hjust=2, size=2, col="blue") +
geom_tiplab(size=2.5) +
xlim(NA, 15)
D = data.frame(cs8, ss8)
p <- ggplot(D, aes(cs8, ss8))
p + geom_point()
ct <- read.tree("run8/RAxML_bestTree.consensus")
st <- read.tree("run8/RAxML_bestTree.synthetic-10")
ggtree(ct)
ggtree(ct)+geom_tiplab()
ggtree(st)+geom_tiplab(size=1)
library(ape)
library(ggtree)
library(hutan)
knitr::opts_knit$set(root.dir = "~/Dropbox-Brown/BlueWaters/R04")
knitr::opts_chunk$set(echo = TRUE)
get_node_support <- function(  tree, treeset, threshold=70 ){
l1 <- length(tree$tip.label)
l2 <- length(treeset[[1]]$tip.label)
if(l1==l2) {
# Returns a vector corresponding to nodes in tree, with percent of trees
# in treeset that contain the corresponding bipartition
clades = prop.clades(tree, treeset) / length(treeset)
nodes = c(rep(NA,length(tree$tip.label)), round(clades*100)) # Offset with NA values for tips
nodes[ length(tree$tip.label) + 1 ] = NA # Set the root value to NA, not a robust way to find root but works in this case
nodes[ nodes < threshold  ] = NA
}
else {
nodes = c(NA)
}
return(nodes)
}
tree_support <- function(tree, treeset) {
len <- length(treeset)
boot <- c(tree, treeset)
class(boot) <- "multiPhylo"
boot<-.compressTipLabel(boot)
support_true <- prop.part(boot[1])
support_boots <- prop.part(boot[2:len+1])
index <- match(support_boots, support_true)
#(attr(sup2, "number")/len2)[i3]
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
compare_support <- function(boot1, boot2) {
len1 <- length(boot1)
len2 <- length(boot2)
boot <- c(boot1, boot2)
class(boot) <- "multiPhylo"
boot <- .compressTipLabel(boot)
support  <- prop.part(boot)
support1 <- prop.part(boot[1:len1])
support2 <- prop.part(boot[len1+1:len2])
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
readnames <- function(  tree  ){
# simplifies taxon names to just numbers rather than reads
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multireadnames <- function( trees ){
ntrees<-lapply(trees, readnames)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
readsynthetic <- function(tree) {
keep = (grepl("hmmsearch2-sample2",tree$tip.label, perl=TRUE))
tree <- drop.tip(tree, which(!keep))
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multisynthetic <- function( trees ){
ntrees<-lapply(trees, readsynthetic)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
setwd("data")
true_tree <- read.tree("run1/simulated_tree.tre")
consensus_boot <- multireadnames( read.tree("run1/RAxML_bootstrap.consensus") )
synthetic_boot <- multisynthetic( read.tree("run1/RAxML_bootstrap.synthetic-10") )
#same.taxa( pop_boot[[1]]$tip.label, ml$tip.label)
true_tree8 <- read.tree("run8/simulated_tree.tre")
consensus_boot8 <- multireadnames( read.tree("run8/RAxML_bootstrap.consensus") )
synthetic_boot8 <- multisynthetic( read.tree("run8/RAxML_bootstrap.synthetic-10") )
cs8 = get_node_support(true_tree8, consensus_boot8, threshold=-1)
ss8 = get_node_support(true_tree8, synthetic_boot8, threshold=-1)
i=1:9
true_trees <- lapply(i, function(x) read.tree(paste0("run",x,"/simulated_tree.tre")))
#class(true_trees)<-"multiPhylo"
consensus <- lapply(i, function(x) multireadnames(read.tree(paste0("run",x,"/RAxML_bootstrap.consensus"))))
synth <- lapply(i, function(x) multisynthetic(read.tree(paste0("run",x,"/RAxML_bootstrap.synthetic-10"))))
csupports <- mapply(function(x,y) get_node_support(x, y, threshold=-1), x=true_trees,y=consensus)
ssupports <- mapply(function(x,y) get_node_support(x, y, threshold=-1), x=true_trees,y=synth)
D_all = data.frame(unlist(csupports), unlist(ssupports))
colnames(D_all) <- c("consensus", "synthetic")
nrow(filter(D_all, !is.na(consensus)))
p_all <- ggplot(D_all, aes(unlist(csupports), unlist(ssupports)))
p_all + geom_point() + coord_equal() + xlab("consensus supports") + ylab("synthetic supports")
consensussupport = get_node_support(true_tree, consensus_boot, threshold=-1)
syntheticsupport = get_node_support(true_tree, synthetic_boot, threshold=-1)
ggtree(true_tree, branch.length='none') +
geom_text(aes(label=consensussupport), vjust=-.5, hjust=2, size=2, col="red") +
geom_text(aes(label=syntheticsupport), vjust=1.5, hjust=2, size=2, col="blue") +
geom_tiplab(size=2.5) +
xlim(NA, 15)
D = data.frame(consensussupport, syntheticsupport)
p <- ggplot(D, aes(consensussupport, syntheticsupport))
p + geom_point()
ggtree(true_tree8, branch.length='none') +
geom_text(aes(label=cs8), vjust=-.5, hjust=2, size=2, col="red") +
geom_text(aes(label=ss8), vjust=1.5, hjust=2, size=2, col="blue") +
geom_tiplab(size=2.5) +
xlim(NA, 15)
D = data.frame(cs8, ss8)
p <- ggplot(D, aes(cs8, ss8))
p + geom_point()
library(ape)
library(ggtree)
library(hutan)
knitr::opts_knit$set(root.dir = "~/Dropbox-Brown/BlueWaters/R04")
knitr::opts_chunk$set(echo = TRUE)
get_node_support <- function(  tree, treeset, threshold=70 ){
l1 <- length(tree$tip.label)
l2 <- length(treeset[[1]]$tip.label)
if(l1==l2) {
# Returns a vector corresponding to nodes in tree, with percent of trees
# in treeset that contain the corresponding bipartition
clades = prop.clades(tree, treeset) / length(treeset)
nodes = c(rep(NA,length(tree$tip.label)), round(clades*100)) # Offset with NA values for tips
nodes[ length(tree$tip.label) + 1 ] = NA # Set the root value to NA, not a robust way to find root but works in this case
nodes[ nodes < threshold  ] = NA
}
else {
nodes = c(NA)
}
return(nodes)
}
tree_support <- function(tree, treeset) {
len <- length(treeset)
boot <- c(tree, treeset)
class(boot) <- "multiPhylo"
boot<-.compressTipLabel(boot)
support_true <- prop.part(boot[1])
support_boots <- prop.part(boot[2:len+1])
index <- match(support_boots, support_true)
#(attr(sup2, "number")/len2)[i3]
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
compare_support <- function(boot1, boot2) {
len1 <- length(boot1)
len2 <- length(boot2)
boot <- c(boot1, boot2)
class(boot) <- "multiPhylo"
boot <- .compressTipLabel(boot)
support  <- prop.part(boot)
support1 <- prop.part(boot[1:len1])
support2 <- prop.part(boot[len1+1:len2])
index1 <- match(support1, support)
index2 <- match(support2, support)
support_m <- matrix(0, nrow=length(support), ncol=2)
support_m[index1, 1] <- attr(support1, "number") / len1
support_m[index2, 2] <- attr(support2, "number") / len2
return(as.data.frame(support_m))
}
readnames <- function(  tree  ){
# simplifies taxon names to just numbers rather than reads
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multireadnames <- function( trees ){
ntrees<-lapply(trees, readnames)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
readsynthetic <- function(tree) {
keep = (grepl("hmmsearch2-sample2",tree$tip.label, perl=TRUE))
tree <- drop.tip(tree, which(!keep))
tips = tree$tip.label
tips <- strsplit(tips,'\\.')
if(substring(tips[[1]][1],1,5)=="reads") {
tips<-lapply(tips, function(y) substring(y[1],6))
}
else { tips<-lapply(tips, function(y) y[1]) }
tree$tip.label = tips
return(tree)
}
multisynthetic <- function( trees ){
ntrees<-lapply(trees, readsynthetic)
class(ntrees)<-"multiPhylo"
return( ntrees )
}
setwd("data")
true_tree <- read.tree("run1/simulated_tree.tre")
consensus_boot <- multireadnames( read.tree("run1/RAxML_bootstrap.consensus") )
synthetic_boot <- multisynthetic( read.tree("run1/RAxML_bootstrap.synthetic-10") )
#same.taxa( pop_boot[[1]]$tip.label, ml$tip.label)
true_tree8 <- read.tree("run8/simulated_tree.tre")
consensus_boot8 <- multireadnames( read.tree("run8/RAxML_bootstrap.consensus") )
synthetic_boot8 <- multisynthetic( read.tree("run8/RAxML_bootstrap.synthetic-10") )
cs8 = get_node_support(true_tree8, consensus_boot8, threshold=-1)
ss8 = get_node_support(true_tree8, synthetic_boot8, threshold=-1)
D = data.frame(consensussupport, syntheticsupport)
p <- ggplot(D, aes(consensussupport, syntheticsupport))
p + geom_point()
ggtree(true_tree8, branch.length='none') +
geom_text(aes(label=cs8), vjust=-.5, hjust=2, size=2, col="red") +
geom_text(aes(label=ss8), vjust=1.5, hjust=2, size=2, col="blue") +
geom_tiplab(size=2.5) +
xlim(NA, 15)
D = data.frame(cs8, ss8)
p <- ggplot(D, aes(cs8, ss8))
p + geom_point()
p_all <- ggplot(D_all, aes(unlist(csupports), unlist(ssupports)))
p_all + geom_point() + coord_equal() + xlab("consensus supports") + ylab("synthetic supports")
library(ape)
setwd("~/Dropbox-Brown/treeinform/ms_treeinform/code")
t<-read.tree("species_tree.tre")
setwd("~/Dropbox-Brown/treeinform/ms_treeinform/code")
library(ape)
knitr::opts_knit$set(root.dir = "~/Dropbox-Brown/treeinform/ms_treeinform/code")
t<-read.tree("species_tree.tre")
chron<-chronos(t)
chron$edge.length<-chron$edge.length*1000000
dup_pdf <- function(s,t,lambda,mu) {
if(s > t) { return(0) }
else {
num <- (lambda-mu)^2*exp(-(lambda-mu)*s)*(lambda - mu*exp(-(lambda-mu)*t))
denom <- (lambda-mu*exp(-(lambda-mu)*s))^2*(1-exp(-(lambda-mu)*t))
f <- num/denom
return(f)
}
}
help(runif)
library(ape)
knitr::opts_knit$set(root.dir = "~/Dropbox-Brown/treeinform/ms_treeinform/code")
l=0.00617025240076
m=0.00634249271090
u = runif(10000, min=0, max=100)
y = unlist(lapply(u, function(x) dup_pdf(x, 100, l, m)))
plot(u, y)
t<-read.tree("../../phyldog-before/3312.StartingTree")
t
t$edge.length
t<-read.tree("../../phyldog-before/3312.ReconciledTree")
t
t$edge
t$edge.length
t$tip.label
t$Nnode
install.packages("treeio")
source("https://bioconductor.org/biocLite.R")
biocLite("treeio")
#' Parses nhx text to a treeio::treedata object
#'
#' @param tree_text Character string repressenting nhx tree
#' @return A treeio::treedata object
#' @export
parse_gene_trees = function( tree_text ){
tree_tc = textConnection( tree_text )
tree = treeio::read.nhx( tree_tc )
close( tree_tc )
# Parse clade labels from phylo object into the data frame
tree@data$label = c( tree@phylo$tip.label, tree@phylo$node.label )
# Compara trees sometimes have speciation nodes whose descendants have the
# same clade name. This isn't biologically possible, so change such nodes
# from speciation events to NA so they don't interfere with tree calibration
# and are not used for calculating speciation contrasts
n_nodes = nrow( tree@data )
n_tips = length( tree@phylo$tip.label )
internal_nodes = ( n_tips + 1 ):n_nodes
is_speciation = tree@data$D == "N"
is_speciation[ is.na( is_speciation ) ] = FALSE
internal_speciation_nodes = tree@data$node[ ( tree@data$node > n_tips ) & is_speciation ]
# Create a vector of clade names of speciation events, with NA for all other nodes
speciation_names = rep( NA, n_nodes )
speciation_names[ internal_speciation_nodes ] = tree@data$label[ internal_speciation_nodes ]
# Loop over the internal speciation nodes
for( i in internal_speciation_nodes ){
# get descendent internal nodes
descendants = hutan::descendants( tree@phylo, i )
descendants = descendants[ descendants %in% internal_nodes ]
descendant_names = speciation_names[ descendants ]
if( speciation_names[i] %in% descendant_names ){
tree@data$D[i] = NA
}
}
# Create a human readable Event column
tree@data$Event = NA
tree@data$Event[ tree@data$D == "N" ] = "Speciation"
tree@data$Event[ tree@data$D == "Y" ] = "Duplication"
tree@data$Event = factor( tree@data$Event, levels=c( "Speciation", "Duplication" ) )
return( tree )
}
parse_gene_trees("../../phyldog-before/3312.StartingTree")
package(treeio)
biocLite("treeio")
install.packages("spdep")
install.packages("spdep")
biocLite("treeio")
source("https://bioconductor.org/biocLite.R")
biocLite("treeio")
biocValid("treeio")
