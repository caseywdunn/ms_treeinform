---
title: "PLOS ONE figures"
output:
  pdf_document: default
  html_notebook: default
---

# Overview

This notebook replicates figures in our PLOS One submission. Some of them are essentially duplicates of other notebooks (i.e. `supplementary_revision.Rmd`), with most of the text left as is, so the text will not necessarily be very coherent. However all of the code should run and replicate the figures just fine. Figures were left to float in the pdf, but code for each figure or table is under the appropriate heading in the `.Rmd` document.

```{r setup, include=FALSE}
library(ape)
library(dplyr)
library(parallel)
library(ggtree)
library(phangorn)
library(Biostrings)
library(BiocGenerics)
library(scales)
library(ggplot2)
library(reshape2)
library(hutan)
library(treeio)
library(knitr)
library(runjags)
library(entropy)
library(treeinform)
cores = detectCores()
if (cores < 1) { cores = 1 }
set.seed(1287234)

source("code/functions.R")
source("code/summary_stats.R")
```

```{r, parse_trees, include=FALSE, warnings=FALSE}
# Parse trees before everything else
# make speciation calibration times (taken from chronos)
age <- c(0.1718036, 0.1430510, 0.2490215, 0.3227746, 0.5157844, 1.0000000)
clade <- c("Calycophora", "Agalmatidae", "Chodorophora", "Siphonophora", "Hydrozoa", "Cnidaria")
calibration_times = data.frame(age, clade, stringsAsFactors = FALSE)

#s <- 1:5606
#before <- dt_phyldog(s, "data/revisions/phyldog/before/", calibration_times)
#trees_before <- before[[1]]
#calibrated_before <- before[[2]]
#dt_before <- before[[3]]
#save(dt_before, file="data/revisions/dt_before.Rdata")
#save(trees_before, file="data/revisions/trees_before.Rdata")
#save(calibrated_before, file="data/revisions/calibrated_before.Rdata")
load("data/revisions/dt_before.Rdata")
load("data/revisions/trees_before.Rdata")
load("data/revisions/calibrated_before.Rdata")

#threshold_4 <- dt_phyldog("data/revisions/phyldog/threshold-4/",calibration_times)[[3]]
#save(threshold_4,file="data/revisions/dt_threshold-4.Rdata")
load("data/revisions/dt_threshold-4.Rdata")

#l <- 36523:43609
#threshold_5 <- dt_phyldog(l, "data/revisions/phyldog/threshold-5/", calibration_times)[[3]]
#save(threshold_5, file="data/revisions/dt_threshold-5.Rdata")
load("data/revisions/dt_threshold-5.Rdata")

#threshold_6 <- dt_phyldog("data/revisions/phyldog/threshold-6/",calibration_times)[[3]]
#save(threshold_6,file="data/revisions/dt_threshold-6.Rdata")
load("data/revisions/dt_threshold-6.Rdata")

#l <- 51176:56944
#threshold_7 <- dt_phyldog(l, "data/revisions/phyldog/threshold-7/", calibration_times)
#dt_7 <- threshold_7[[3]]
#save(dt_7, file="data/revisions/dt_threshold-7.Rdata")
load("data/revisions/dt_threshold-7.Rdata")

#l <- 58509:65608
#threshold_8 <- dt_phyldog(l, "data/revisions/phyldog/threshold-8/", calibration_times)[[3]]
#save(threshold_8, file="data/revisions/dt_threshold-8.Rdata")
load("data/revisions/dt_threshold-8.Rdata")

#l <- 88484:94021
#threshold_mix <- dt_phyldog(l, "data/revisions/phyldog/mix/", calibration_times)[[3]]
#save(threshold_mix, file="data/revisions/dt_threshold-mix.Rdata")
load("data/revisions/dt_threshold-mix.Rdata")
```

# Figure 1: Example Siphonophora gene tree pre-treeinform

Data consists of:

- **data/revisions/phyldog/before/7.ReconciledTree**: Gene tree generated by Agalma1.1.0 and phyldog before running treeinform. This can be regenerated using our scripts in **code/2_agalma_analysis**.
- **data/revisions/7.fa**: Multiple sequence alignment 7 from Agalma1.1.0 which corresponds to gene tree 7. This gene tree was selected through a manual search through the set of pre-treeinform gene trees for a calde of genes from the same species with improbably short terminal branches.

```{r fig1a, echo=FALSE, include=FALSE}
fig1a_tree = read.nhx("data/revisions/phyldog/before/7.ReconciledTree")@phylo
fig1a_colors = rep(1, length(fig1a_tree$tip.label)+fig1a_tree$Nnode)
#32566, 32567, 32568, 32569 are the model IDs we're looking for
# here they are 30,31,32,33
fig1a_colors[30:33] = 2
hydra_ancestor = getMRCA(fig1a_tree, 30:33)
fig1a_colors[hydra_ancestor] = 2

phyDat = read.phyDat("data/revisions/7.fa", format="fasta", type="AA")
fit = pml(fig1a_tree, phyDat)
#anc.ml = ancestral.pml(fit, "ml")
anc.ml = ancestral.pml(fit, "ml", return="phyDat")
# root is 34
test = as.character(anc.ml)
anc.seq = test[34,]
diff = sweep(test, 2, anc.seq, "==")

test_sum = apply(diff*1, 2, sum)
test_order = order(test_sum, decreasing=TRUE)
ordered_diff = diff[,test_order]

test_diff = apply(ordered_diff, c(1,2), function(x) if(x) { return("A") } else { return("C") })
test_DNAbin = as.DNAbin(test_diff)
#write.dna(test_DNAbin, "data/plos_msa.fasta", format="fasta", nbcol=-6, colsep='')

label = sapply(strsplit(sapply(strsplit(fig1a_tree$tip.label, "\\."), function(x) x[1]), "_"), function(x) x[1])

new_tree = chronos(fig1a_tree)
class(new_tree) = "phylo"
ggnt <- ggtree(new_tree)
ggnt$data$label[34:65] <- 34:65 # to deal with the fact that test_DNAbin labels are 34:65 instead of NA
```

```{r plot, echo=FALSE, warning=FALSE, fig.cap='An example gene phylogeny from the test dataset before running treeinform. Each tip is an exemplar transcript that was initially assigned to a different gene. In front, corresponding multiple sequence alignment, with sites ordered from highest to lowest identity to the inferred ancestral site for clarity on sequence diversity. Black indicates a difference from the ancestral sequence. The four Hydra transcripts in color were assigned to different genes by Trinity despite two of the transcripts sharing the exact same sequences, and the two other transcripts differing by a small gap. After treeinform, all transcripts from these four genes are reassigned to a single gene.'}
#tiff(filename="Figures/figure1.tiff",width=7,height=5,units="in",pointsize=8,res=350)
#postscript(file="Figures/figure1_revision.eps",width=7,height=5,fonts=c("sans"))
#cairo_ps(file="Figures/figure1_revision.eps",width=7,height=5,pointsize=8)
msaplot(ggnt, test_DNAbin, color=c("white","black","white","white"), offset=0.3, width=0.8) + geom_tiplab(size=4, aes(color=fig1a_colors), label=label) + theme(legend.position="none")
#dev.off()
```

# Table 1: Summary of parameter estimates from JAGS

 * The code to run JAGS is commented out as it takes ~3 hours on a 2018 MacBook Pro. Instead we load it from **data/revisions/runjags_results.Rdata**.

```{r, runjags, include=FALSE}
# Data
Y = dt_before
N = length(dt_before)

# Initial values to get the chains started:
alpha <- 1
beta <- 1
lambda <- 0.571990480546
mu <- 0.544504933034
t <- 1
Constant <- 10

Ones <- rep(1, N)

#results <- run.jags(model="code/runjags.txt", n.chains=3, thin=1) # will take ~1hr
#results <- autorun.jags(model="code/runjags_revision.txt", n.chains=3, thin=1) # will take ~3hrs
#results_extend <- extend.jags(results, add.monitor=c("component_chosen")) # will take ~24hrs
#save(results, file="data/revisions/runjags_results2.Rdata")
load("data/revisions/runjags_results2.Rdata")
sum_results = results$summaries

alpha = sum_results[1,4]
beta = sum_results[2,4]
mu = sum_results[3,4]
lambda = sum_results[4,4]
p1 = sum_results[5,4]
p2 = sum_results[6,4]

mix1 = function(x, p1=p1, alpha=alpha, beta=beta) { p1*dgamma(x,shape=alpha,scale=beta)}
mix2 = function(x, p2=p2, lambda=lambda,mu=mu) { p2*dup_pdf(x,1,lambda,mu)}

load("data/revisions/posterior_component1.Rdata")
df_post = suppressWarnings(data.frame(dt=dt_before,pc1=posterior_component1) %>% filter(posterior_component1>0))
intersection = filter(df_post, pc1 >= 0.95) %>% select(dt) %>% max

#intersection = uniroot(function(x) mix1(x,p1,alpha,beta)-mix2(x,p2,lambda,mu), c(0,0.25))$root
```

We expected the implied duplication events of transcripts of the same gene that were misassigned to different genes to have very short implied duplication times approaching 0, and thus chose to model that component (Component 1) as a gamma distribution with parameters shape$=\alpha$ and rate$=\beta$. To model duplication events and associated times arising from the correctly assigned transcripts (Component 2), we used a birth-death process [@gernhard2008conditioned], which is well studied and often applied to gene analyses of duplication and loss. The probability distribution function in the model we used has parameters birth rate $\lambda$, death rate $\mu$, and tree time of origin $t_{or}$. Because we fitted a chronogram with time of origin 1 onto the gene trees $G = \{ G_1, G_2, \ldots, G_K \}$, we made the assumption that all gene tree times of origin are $t_{or} = 1$. Some gene trees have duplication events predating the first speciation event, thus when we fitted chronograms onto those gene trees they had times of origin greater than 1. We chose to filter these gene trees out of the mixture model and subsequent analyses.

Let $x_{i, k}$ represent duplication time $i$ from gene tree $G_k$, with $z_{i} \in \{ 1, 2 \}$ representing whether $x_{i,k}$ is drawn from the 1st component $(z_i = 1)$ or the 2nd component $(z_i = 2)$. Then if $\pi_1$ and $\pi_2$ denote the overall probability that a duplication time belongs to the 1st and 2nd component respectively, $\Gamma(x_{i,k} | \alpha, \beta)$ is the probability density function for the gamma distribution, and $f(x_{i,k} | t_{or,k} = 1, \lambda, \mu)$, we get the expression

$$ P(x_{i,k}) = \pi_1 \Gamma(x_{i,k}|\alpha, \beta) + \pi_2 f(x_{i,k} | t_{or,k}=t, \lambda, \mu)$$

We used Just Another Gibbs Sampler (JAGS) [@Plummer03jags] to perform Bayesian Gibbs Sampling in order to infer the parameters $\alpha$, $\beta$, $\lambda$, and $\mu$ as well as the mixing proportions $\pi_1$ and $\pi_2$. This gave us the parameter estimates in Table 2.

```{r, runjags_table, echo=FALSE}
sum_format = sum_results[,c("Lower95", "Mean", "Upper95", "MCerr")]
rownames(sum_format) <- c("$\\alpha$", "$\\beta$", "$\\mu$", "$\\lambda$", "$\\pi_1$", "$\\pi_2$")
kable(sum_format, format='pandoc', caption='Summary of parameter estimates from JAGS.')
#kable(sum_format, format='latex', caption='Summary of parameter estimates from JAGS.', booktabs = T)
```

# Table 2: Adjusted Rand Index between Trinity and Corset

# Figure 2: Subtree lengths for Siphonophora pre-treeinform

We first examined the prevalence of transcript misassignment. For each node in each of the `r toString(length(trees_before))` gene phylogenies, we calculated the length of the corresponding subtree. This is the sum of the length of all branches in the subtree defined by the node. An excess of very short subtrees would be a strong indication of assigning different transcripts of the same gene, which have very similar sequences and therefore short branches connecting them in phylogenetic trees, to different genes. This is the pattern we found (Supplementary Figure 1).

Two issues could create a misleading impression in the histogram of subtree lengths for internal nodes (Supplementary Figure 1). First, it considers all subtrees, including those defined by both speciation and duplication nodes. Misassigning transcripts from the same gene to multiple genes will artificially inflate only the number of duplication nodes, since variation across transcripts within a gene are essentially misassigned to gene duplication events. Examining just the duplication events in the gene trees therefore provides a more direct perspective on the problem we investigate here. Second, subtree lengths are in units of expected numbers of substitution, which depend on both rates of molecular evolution and time. Because the rates of evolution can vary within and between gene phylogenies, variation in rates could confound the interpretation of gene tree sublength. 

We therefore performed a calibrated analysis and focused only on duplication nodes. We first created a time calibrated species tree, with all tips with age 0 and the root node with age 1. We then transformed the branch lengths of the gene trees so that each speciation node in each gene tree had the same age as the corresponding node in the species tree (see source code for this document). A histogram of the calibrated duplication times (Supplementary Figure 2) indicates there is a large excess of recent duplications. This provides additional evidence for the frequent misassignment of transcripts from the same gene to artefactual recent gene duplicates.

```{r, subtree_histo, echo=FALSE, warning=FALSE, fig.cap="Histogram of subtree lengths for internal nodes in each Siphonophora subset gene tree from Agalma containing tip descendants from the same species. Subtree lengths greater than 1 were filtered out for clarity."}
lengths = unlist(multi_subtree_lengths(trees_before, cores))

lengths_lim = lengths[which(lengths<1)]

#tiff(filename="Figures/subtree_lengths.tiff",width=7,height=5,family="Arial",units="in",pointsize=8,res=350)
#pdf(file="Figures/subtree_lengths.eps",width=7,height=5,fonts=c("sans"))
ggplot(data=data.frame(x=lengths_lim)) + geom_histogram(aes(x=x,y=..count../sum(..count..)), binwidth=0.01, fill='white', color='black') + theme_classic() + xlab("Subtree length") + ylab("Frequency") #+ geom_vline(xintercept=0.02, linetype='dashed', color='#56B4E9') + geom_text(data=data.frame(x=0.02,y=0.08), map=aes(x=x, y=y), label="0.02", vjust=1.4, angle=90, colour="#56B4E9", size=3)
#dev.off()
```

# Figure 3: Corset clusterings

In order to get a sense of whether the transcript misassignment errors were localized to Trinity or are a more general problem to transcriptome assembly, we compared Trinity transcript clustering results with another transcript clustering tool, Corset [@Davidson2014] for the 5 species that had to be assembled. For 3 of the samples (SRX288285, SRX288430, SRX288431) we also ran cd-hit [@Fu2012] to remove transcripts with 100% identity in order to address some speed issues in Corset. The distribution of cluster sizes (Supplementary Figure 2) suggests that Corset tends to overcluster compared to Trinity, which would lead to similar misassignment errors.

```{r, corset_compare, echo=FALSE, warnings=FALSE, fig.cap="Cluster size counts for Trinity assembly and Corset clustering algorithm on Trinity contigs. There are 3 Trinity clusters with size greater than 30, while there are 20 Corset clusters with size greater than 30. This suggests that the same misassignment errors are generated by other transcriptome assemblers and clustering algorithms as well."}
#clusters.mod.txt <- (Sys.glob("data/revisions/corset/*-clusters.mod.txt"))
#corset_files <- lapply(clusters.mod.txt, function(x) read.csv(x, sep="\t", col.names = c("Trinity gene", "Trinity isoform", "Corset gene")))
#save(corset_files, file="data/revisions/corset_clusters.Rdata")
load("data/revisions/corset_clusters.Rdata")

trinity_clusters <- lapply(corset_files, function(x) cluster_size_distribution(x$Trinity.gene))
corset_clusters <- lapply(corset_files, function(x) cluster_size_distribution(x$Corset.gene))
catalog_ids=c('SRX288276','SRX288285','SRX288430','SRX288431','SRX288432')
suppressWarnings(size_dist_dfs<-lapply(1:5, function(x)
  {
  nrx<-nrow(trinity_clusters[[x]])
  nry<-nrow(corset_clusters[[x]])
  nrt<-nrx+nry
  df<-rbind(trinity_clusters[[x]],corset_clusters[[x]])
  tmp <- rep("Trinity", nrt)
  tmp[nrx+1:nry]<-"Corset"
  df$'Method' <- tmp
  df$'ID' <- catalog_ids[x]
  return(df)
  }))
suppressWarnings(new_df <- do.call(rbind, size_dist_dfs))

# basic stats about corset & trinity
trinity_over_30<-filter(new_df, Method=='Trinity' & as.numeric(levels(size))[size]>30)
num_trinity_over_30<-sum(trinity_over_30$freq) # returns 3
corset_over_30<-filter(new_df, Method=='Corset' & as.numeric(levels(size))[size]>30)
num_corset_over_30<-sum(corset_over_30$freq) # returns 20

#tiff(filename="Figures/corset_cluster.tiff",width=7,height=5,family="Arial",units="in",pointsize=8,res=300)
#pdf(file="Figures/corset_cluster.pdf",width=7,height=5,fonts=c("sans"))
suppressWarnings(ggplot(data=new_df,aes(x=size,y=freq,color=Method,group=Method))+geom_point(alpha=0.7)+scale_y_log10()+xlab("Cluster Size")+ylab("Count") + theme_classic() + geom_line() + facet_wrap(~ID, ncol=2) + scale_x_discrete(breaks=seq(0,70,by=10)))
# no titles for plos
#+ggtitle("Cluster size counts for Trinity & Corset by sample")
#dev.off()
```

# Figure 4: Subtree lengths after corset

```{r, corset_trees, echo=FALSE, warning=FALSE, fig.cap="Histogram of subtree lengths for internal nodes in each Siphonophora subset gene tree from Agalma with Corset clusterings containing tip descendants from the same species. Subtree lengths greater than 1 were filtered out for clarity."}
#k<-1:5644
#corset_tree_files <- "data/revisions/corset/phyldog/"
#corset_trees <- mclapply(k, function(x) parse_gene_trees(processTree(paste0(corset_tree_files, x, ".ReconciledTree"))), mc.cores = cores)
#corset_trees <- corset_trees[which(!unlist(mclapply(corset_trees, is.null)))]
#save(corset_trees, file="data/revisions/corset_trees.Rdata")
load("data/revisions/corset_trees.Rdata")
corset_lengths <- unlist(multi_subtree_lengths(corset_trees,cores))
corset_lengths_lim = corset_lengths[which(corset_lengths<1)]

# are corset subtree lengths different from trinity...?
trinity_corset_ks <- ks.test(corset_lengths,lengths)$statistic
rejection_level_tc <- 1.36*sqrt((length(corset_lengths)+length(lengths))/(length(corset_lengths)*length(lengths)))

#tiff(filename="Figures/corset_lengths.tiff",width=7,height=5,family="Arial",units="in",pointsize=8,res=300)
#postscript(file="Figures/corset_lengths.eps",width=7,height=5,fonts=c("sans"))
ggplot(data=data.frame(x=corset_lengths_lim)) + geom_histogram(aes(x=x,y=..count../sum(..count..)), binwidth=0.01, fill='white', color='black') + theme_classic() + xlab("Subtree length") + ylab("Frequency") #+ geom_vline(xintercept=0.02, linetype='dashed', color='#56B4E9') + geom_text(data=data.frame(x=0.02,y=0.08), map=aes(x=x, y=y), label="0.02", vjust=1.4, angle=90, colour="#56B4E9", size=3)
#dev.off()
```

# Figure 5: Mixture model

```{r, runjags_viz, echo=FALSE, warnings=FALSE, fig.cap='Histogram of the inferred duplication times with an overlaid mixture model. Component 1 of the mixture model captures the technical issues we address where transcripts from the same gene are assigned to different genes, and component 2 captures the biological pattern, i.e. transcripts from different genes correctly assigned so. We first ran phyldog [@boussau2013genome] on the Siphonophora subset multiple sequence alignments from Agalma and a user-inputted species tree. This provided gene trees with internal nodes annotated as duplication or speciation events. We then fitted chronograms onto these gene trees with our user-inputted species tree.'}
#tiff(filename="Figures/mixmodel.tiff",width=7,height=5,family="Arial",units="in",pointsize=8,res=350)
#pdf(file="Figures/mixmodel.pdf",width=7,height=5,fonts=c("sans"))
ggplot(data.frame(x=dt_before)) + geom_histogram(aes(x=x,y=..density..), fill='white', color='black', binwidth=0.01) + stat_function(geom="line",fun=mix1,args=list(p1,alpha,beta),xlim=c(0.005,1), aes(color="line1"))+stat_function(geom="line",fun=mix2,args=list(p2,lambda,mu),aes(color="line2"))+ggtitle("Density Curves of Mixture Model Plotted on Histogram of\n Inferred Duplication Times Before Treeinform") + scale_color_manual("Components of Mixture Model", labels=c('line1' = expression("Component 1, " * pi[1]*Gamma(x, alpha, beta)), 'line2' = expression("Component 2, "*pi[2]*f(x,1,lambda,mu))), values=c("#FF000080", "blue")) + xlab("Duplication Times") + ylab("Density") + theme_classic() + theme(legend.position = c(0.8, 0.6))
#dev.off()

#z = theme(legend.position = "none", text=element_text(colour='#838787', size = 20), plot.background=element_rect(fill ='#222222'), panel.background=element_rect(fill='#222222'), legend.background=element_rect(fill='#222222'), axis.line=element_line(colour='#838787'), axis.text=element_text(colour='#838787', size=15), axis.ticks = element_line(colour='#838787'), line=element_line(size=5))
#ggplot(data.frame(x=dt_before)) + geom_histogram(aes(x=x,y=..density..), fill='#838787', color='black', binwidth=0.01) + geom_vline(xintercept=0.01, linetype='dashed', color='yellow') + geom_text(data=data.frame(x=0.01,y=5), map=aes(x=x, y=y), label="0.01", vjust=1.4, angle=90, colour="yellow", size=8) + stat_function(geom="line",fun=mix1,args=list(p1,alpha,beta),xlim=c(0.003,1), colour="#E42832", size=1)+stat_function(geom="line",fun=mix2,args=list(p2,lambda,mu),colour="#34A5DA", size=1) + ylab("Density") + xlab("Time") + theme_classic() + z
```

# Figure 6: Reassigned percentage

```{r, fused_percentage_pre, echo=FALSE, warnings=FALSE}
genetree_path <- "data/revisions/genetrees/"
thresholds<-head(list.files(genetree_path), -1)
before_genetrees<-read_trees(paste0(genetree_path,"before"),"newick",cores)
phylos<-lapply(before_genetrees, function(x) x@phylo)
before_counts<-count_all_transcripts(phylos,cores)
orig_assembly = sum(before_counts)

#genetrees<-lapply(thresholds, function(x) read_trees(paste0(genetree_path,x), "newick",cores))
#counts<-lapply(genetrees, function(x) count_all_transcripts(x,cores))
#save(counts,file="data/revisions/counts.Rdata")
load(file="data/revisions/counts.Rdata")
Total_percentage<-sapply(counts, function(x) sum(before_counts-x)/orig_assembly)

percentages<-mclapply(counts, function(x) (before_counts-x)/before_counts,mc.cores=cores)
size<-rep(1,8*length(percentages))
size[(7*length(percentages)+1):(8*length(percentages))]<-2
size<-as.factor(size)
thresholds<-as.numeric(thresholds)
wide_table<-data.frame(cbind(do.call(rbind,percentages),thresholds,Total_percentage))
colnames(wide_table) <- sapply(strsplit(colnames(wide_table),"_"),function(x) x[1])
long_table<-melt(wide_table,id.vars=c("thresholds"))
long_table<-cbind(long_table,size)
long_table$value<-as.numeric(long_table$value)
long_table$thresholds<-as.numeric(long_table$thresholds)

# coloring for threshold selection & mixture model selection
#grp <- c(rep(1, 18), 2)
#fused.df.percents <- cbind(fused.df.percents, grp)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")

hydra_percentage<-sapply(1:4, function(x) (before_counts-counts[[x]])[4]/sum(before_counts-counts[[x]]))
default_percentages<-filter(long_table, thresholds==5e-04)
```

In order to validate that treeinform improves the accuracy of assigning transcripts to genes under the specified threshold, we performed two analyses. First, we plotted the percentage of reassigned genes at different thresholds to assess the performance of the default threshold value of 0.0005 (Supplementary Figure 5). Below the default value, the percentage of reassigned genes begins to plateau, while above the default value the percentage of reassigned genes increases very quickly, increasing the likelihood of treeinform to reassign transcripts from different genes to the same gene in addition to reassign transcripts from the same gene together.

```{r, fused_percentage, echo=FALSE, warnings=FALSE, fig.cap="The percentage of reassigned tips is plotted above on a log scale. The original assembly had 433,071 genes, with 47,688 included in the gene trees after Agalma filtering criteria, and at most 23,396 possible candidates (49.06% of genes) for reassignment. The default threshold for treeinform is marked by the grey vertical dashed line."}
#tiff(filename="Figures/reassigned.tiff",width=7,height=5,family="Arial",units="in",pointsize=8,res=300)
#pdf(file="Figures/reassigned.pdf",width=7,height=5,fonts=c("sans"))
ggplot(long_table,aes(thresholds,value*100)) + geom_vline(xintercept=0.0005, linetype='dashed', color='grey') + geom_text(data=data.frame(x=0.0005,y=0.25), map=aes(x=x, y=y), label="0.0005", vjust=1.4, angle=90, colour="grey", size=3) + geom_point(aes(group=variable,color=variable,shape=size), alpha=0.5) + geom_line(aes(group=variable,color=variable,linetype=size)) + xlab("Threshold") + ylab("Percentage") + scale_x_log10() + theme_classic() + scale_shape(guide="none") + scale_linetype(guide="none") + scale_colour_manual(name="Species",labels=c("Abylopsis","Agalma","Craseoa","Hydra","Nanomia","Nematostella","Physalia","Total"),values=cbbPalette)
#+ ggtitle("Percentage of reassigned genes by species + total percentage vs threshold")
#dev.off()
```

# Figure 7 - Density theoretical
