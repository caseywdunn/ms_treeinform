---
title: Revising transcriptome assemblies with phylogenetic information in Agalma1.0
  - Supplementary Information
output:
  pdf_document:
    toc: yes
  html_notebook: default
  html_document: default
bibliography: supplementary.bib
---

```{r, setup, include=FALSE}
library(ape)
library(scales)
library(ggplot2)
library(dplyr)
library(hutan)
library(treeio)
library(parallel)
library(knitr)
library(runjags)
library(entropy)

cores = detectCores()
if (cores < 1) { cores = 1 }
set.seed(1287234)

source("code/functions.R")
```

```{r, parse_trees, include=FALSE, warnings=FALSE}
# Parse trees before everything else
# make speciation calibration times (taken from chronos)
age <- c(0.1718036, 0.1430510, 0.2490215, 0.3227746, 0.5157844, 1.0000000)
clade <- c("Calycophora", "Agalmatidae", "Chodorophora", "Siphonophora", "Hydrozoa", "Cnidaria")
calibration_times = data.frame(age, clade, stringsAsFactors = FALSE)

#5299 gene trees + 5301 (missing 5300)
s <- 1:360
#before <- dt_phyldog(s, "data/before/", calibration_times)
#trees_before <- before[[1]]
#calibrated_before <- before[[2]]
#dt_before <- before[[3]]
#save(dt_before, file="data/dt_before.Rdata")
#save(trees_before, file="data/trees_before.Rdata")
#save(calibrated_before, file="data/calibrated_before.Rdata")
load("data/dt_before.Rdata")
load("data/trees_before.Rdata")
load("data/calibrated_before.Rdata")

#l <- 27804:28204
load("data/dt_threshold-5.Rdata")

#threshold_2 <- dt_phyldog(l, "data/threshold-2/", calibration_times)[[3]]
#save(threshold_2, file="data/dt_threshold-2.Rdata")
load("data/dt_threshold-2.Rdata")

#threshold_8 <- dt_phyldog(l, "data/threshold-8/", calibration_times)[[3]]
#save(threshold_8, file="data/dt_threshold-8.Rdata")
load("data/dt_threshold-8.Rdata")

load("data/dt_threshold-6.Rdata")

#threshold_mix <- dt_phyldog(l, "data/threshold-mix/", calibration_times)[[3]]
#save(threshold_mix, file="data/dt_threshold-mix.Rdata")
load("data/dt_threshold-mix.Rdata")
```

## Supplementary methods

The code for the analyses presented here (including an executable version of this document) are available in a git repository at https://github.com/caseywdunn/ms_treeinform. The phylogenetic analyses considered here are based on a 7 taxon siphonophore (XX doi:10.1016/j.cub.2009.02.009) dataset. This dataset (XX explain the origin of this dataset and why it was selected). Full details on how the phylogenetic analyses were implemented in Agalma are available in the GitHub repository folder XXX. The gene trees were built with Agalma1.0, and bash scripts for the run can be found [xxx]

The phylogenetic analyses in Agalma followed standard approaches with default settings. Speciation and duplication nodes were identified in the gene trees with XX.

Agalma uses the transcriptome assembler Trinity (XX). Given the intrinsic challenges of assigning assembled transcripts to genes it is likely that the same misassignment errors are generated by other transcriptome assemblers as well.

## Assessing the extent of transcript assignment errors

We first examined the prevalence of transcript misassignment. For each node in each of the 5304 gene phylogenies, we calculated the length of the corresponding subtree. This is the sum of the length of all branches in the subtree defined by the node. An excess of very short subtrees would be a strong indication of assigning different transcripts of the same gene, which have very similar sequences and therefore short branches connecting them in phylogenetic trees, to different genes. This is the pattern we found (Supplementary Figure 1).

Two issues could create a misleading impression in the histogram of subtree lengths for internal nodes (Supplementary Figure 1). First, it considers all subtrees, including those defined by both speciation and duplication nodes. Misassigning transcripts from the same gene to multiple genes will artificially inflate only the number of duplication nodes, since variation across transcripts within a gene are essentially misassigned to gene duplication events. Examining just the duplication events in the gene trees therefore provides a more direct perspective on the problem we investigate here. Second, subtree lengths are in units of expected numbers of substitution, which depend on both rates of molecular evolution and time. Because the rates of evolution can vary within and between gene phylogenies, variation in rates could confound the interpretation of gene tree sublength. 

We therefore performed a calibrated analysis and focused only on duplication nodes. We first created a time calibrated species tree, with all tips with age 0 and the root node with age 1. We then transformed the branch lengths of the gene trees so that each speciation node in each gene tree had the same age as the corresponding node in the species tree (see source code for this document). A histogram of the calibrated duplication times (Supplementary Figure 2) indicates there is a large excess of recent duplications. This provides additional evidence for the frequent misassignment of transcripts from the same gene to artefactual recent gene duplicates.



```{r, subtree_histo, echo=FALSE, warning=FALSE, fig.cap="Histogram of subtree lengths for internal nodes in each Siphonophora subset gene tree from Agalma1.0 containing tip descendants from the same species. Subtree lengths greater than 1 were filtered out for clarity."}
lengths = mclapply(trees_before, function(x) {
  phylo = x@phylo
  nnode = phylo$Nnode
  data = x@data
  bl = c(phylo$edge.length, 0)
  data[,'bl'] = bl[order(c(phylo$edge[,2], length(phylo$tip.label)+1))]
  des = lapply(length(phylo$tip.label)+1:nnode, function(z) descendants(phylo, z))
  td = lapply(length(phylo$tip.label)+1:nnode, function(z) tip_descendants(phylo, z))
  duplicates = sapply(td, function(z) {
      sapply(strsplit(names(z), '@'), '[')[1,] %>% duplicated %>% any
    })
  only_duplicates = des[which(duplicates)]
  len = lapply(only_duplicates, function(z) {
      filter(data, node %in% z) %>% select(bl) %>% sum
    })
  return(len)
  }, mc.cores=cores)

lengths_lim = unlist(lengths)[which(unlist(lengths)<1)]

#heights = read.table("data/7taxa_treeinform_histo.out", sep=" ", fill=TRUE, header=FALSE, colClasses = c("numeric", rep("integer", 15))) # don't actually know what max clade size is but assuming it's 15
#colnames(heights) <- c("height", sapply(1:15, function(x) paste0("ID",x)))
ggplot(data=data.frame(x=lengths_lim)) + geom_histogram(aes(x=x,y=..count../sum(..count..)), binwidth=0.01, fill='white', color='black') + theme_classic() + xlab("Subtree length") + ylab("Frequency") + geom_vline(xintercept=0.02, linetype='dashed', color='blue') + geom_text(data=data.frame(x=0.02,y=0.08), map=aes(x=x, y=y), label="0.02", vjust=1.4, angle=90, colour="blue", size=3)
# + scale_x_sqrt(breaks = trans_breaks("sqrt", function(x) x^2), labels = trans_format("sqrt", math_format(.x^2))) more striking difference on sqrt scale, but harder to compare with Supplementary Figure 2
```

## Selecting a threshold for transcript reassignment

```{r, runjags, include=FALSE}
#load("data/dt_before.Rdata")

# Data
Y = dt_before
N = length(dt_before)

# Initial values to get the chains started:
alpha <- 1
beta <- 1
lambda <- 0.637025240076
mu <- 0.614249271090
t <- 1
Constant <- 10

Ones <- rep(1, N)

#results <- run.jags(model="code/runjags.txt", n.chains=3, thin=1) # will take ~1hr
#results <- autorun.jags(model="code/runjags.txt", n.chains=3, thin=1) # will take ~3hrs
#save(results, file="data/runjags_results.Rdata")
load("data/runjags_results.Rdata")
sum_results = results$summaries

alpha = sum_results[1,4]
beta = sum_results[2,4]
mu = sum_results[3,4]
lambda = sum_results[4,4]
p1 = sum_results[5,4]
p2 = sum_results[6,4]

mix1 = function(x, p1=p1, alpha=alpha, beta=beta) { p1*dgamma(x,shape=alpha,scale=beta)}
mix2 = function(x, p2=p2, lambda=lambda,mu=mu) { p2*dup_pdf(x,1,lambda,mu)}

intersection = uniroot(function(x) mix1(x,p1,alpha,beta)-mix2(x,p2,lambda,mu), c(0,0.25))$root
```

```{r, back_calibrate, warnings=FALSE, include=FALSE}
# find duplication events with t<=intersection in calibrated trees
calibrated_thresh = mclapply(calibrated_before, function(x)
  {
  if(is.na(x)) { return(NA) }
  else {
    l = length(x@phylo$tip.label)
    filter(x@data, height <= intersection, node > l) %>% select(node) %>% unlist }
  }, mc.cores = cores)

# compute subtree length for equivalent event in uncalibrated trees
subtree_lengths = mcmapply(function(x, y) {
  if(length(x)==0 || is.na(x)) { return(0) }
  else {
    phylo = y@phylo
    data = y@data
    bl = c(phylo$edge.length, 0)
    data[,'bl'] = bl[order(c(phylo$edge[,2], length(phylo$tip.label)+1))]
    des = lapply(x, function(z) descendants(phylo, z))
    len = lapply(des, function(z) {
      filter(data, node %in% z) %>% select(bl) %>% sum
    })
    return(len)
  }
}, calibrated_thresh, trees_before, mc.cores=cores)

# select max out of subtree lengths
thresh = unlist(subtree_lengths) %>% max
```


A visual inspection of the histogram of subtree lengths (Supplementary Figure 1) suggested that 0.02 was an appropriate threshold for this particular dataset, as the frequency of subtree length for internal nodes was high below such threshold but leveled out above it. In addition, 19.12% of internal nodes containing tip descendants from the same species had a subtree length less than 0.01, with an additional 2.17% having a subtree length between 0.01 and 0.02. It is unlikely that all of these clades are gene duplication events.

These observations suggest that two different processes are operating simultaneously to generate the observed subretree lengths, one for the misassigned transcripts and one for the correctly assigned transcripts. To model this pattern, we used a mixture model onto the inferred duplication times (equivalent to branch lenghts; see main text) from the gene trees. One component modelled duplication events and associated times arising from transcripts assigned to different genes that belong to the same gene (i.e., misassigned transcripts), and the other component modelled duplication events and associated times arising from transcripts assigned to different genes that in fact do belong to different genes (i.e., corrrectly assigned transcripts) (Supplementary Figure 2).

To model each component of the mixture model, we used birth-death phylogenetic models, which are well studied and often applied to gene analyses of duplication and loss. We expected the implied duplication events of transcripts of the same gene that were misassigned to different genes to have very short implied duplication times approaching 0, and thus chose to model that component (Component 1) as a gamma distribution with parameters shape$=\alpha$ and rate$=\beta$. For duplication events from transcripts assigned to different genes that in fact do belong to different genes, we used the probability distribution function given by Gernhard [@gernhard2008conditioned] (Component 2) which has parameters birth rate $\lambda$, death rate $\mu$, and tree time of origin $t_{or}$. Because we fitted a chronogram with time of origin 1 onto the gene trees $G = \{ G_1, G_2, \ldots, G_K \}$, we made the assumption that all gene tree times of origin are $t_{or} = 1$, although technically it is an incorrect estimate of the age of both the gene tree and the species tree. Some gene trees have duplication events predating the first speciation event, thus when we fitted chronograms onto those gene trees they had times of origin greater than 1. We chose to filter these gene trees out of the mixture model and subsequent analyses.

If $x_{i, k}$ represents duplication times $i$ from gene tree $G_k$, $\pi_1$ and $\pi_2$ denote the probability that a duplication time belongs to the 1st and 2nd component respectively, $\Gamma(x_{i,k} | \alpha, \beta)$ is the probability density function for the gamma distribution, and $f(x_{i,k} | t_{or,k} = 1, \lambda, \mu)$, then we get the expression

$$ P(x_{i,k}) = \pi_1 \Gamma(x_{i,k}|\alpha, \beta) + \pi_2 f(x_{i,k} | t_{or,k}=t, \lambda, \mu)$$

We used Just Another Gibbs Sampler (JAGS) [@Plummer03jags] to perform Bayesian Gibbs Sampling in order to infer the parameters $\alpha$, $\beta$, $\lambda$, and $\mu$ as well as the mixing proportions $\pi_1$ and $\pi_2$. This gave us the parameter estimates in Table 1.

```{r, runjags_table, echo=FALSE}
sum_format = sum_results[,c("Lower95", "Mean", "Upper95", "MCerr")]
rownames(sum_format) <- c("$\\alpha$", "$\\beta$", "$\\mu$", "$\\lambda$", "$\\pi_1$", "$\\pi_2$")
kable(sum_format, format='pandoc', caption='Summary of parameter estimates from JAGS.')
```

As the intersection point of the two components of the mixture model signals the duplication time point at which more duplication events are likely to arise from transcripts from different genes assigned to different genes, back-calibrating that intersection point provided a threshold for use in treeinform. Specifically, we took all duplication events with times below the intersection point on all chronogram-fitted gene trees, mapped them to the equivalent events on the phyldog-outputted gene trees, computed the subtree length of all events, and then took the maximum of those subtree lengths. From the intersection point `r toString(intersection)`, this gave us a threshold of `r toString(thresh)`. This suggested that a threshold choice of 0.02 was appropriate, consistent with the threshold sugged by Supplementary Figure 1.


```{r, runjags_viz, echo=FALSE, warnings=FALSE, fig.cap='Histogram of the inferred duplication times. We first ran phyldog [@boussau2013genome] on the Siphonophora subset multiple sequence alignments from Agalma1.0 and a user-inputted species tree. This provided gene trees with internal nodes annotated as duplication or speciation events. We then fitted chronograms onto these gene trees with our user-inputted species tree. In the overlaid mixture model, the intersection point between the two distribution curves was 0.009.'}
ggplot(data.frame(x=dt_before)) + geom_histogram(aes(x=x,y=..density..), fill='white', color='black', binwidth=0.01) + stat_function(geom="line",fun=mix1,args=list(p1,alpha,beta),xlim=c(0.005,1), aes(color="line1"))+stat_function(geom="line",fun=mix2,args=list(p2,lambda,mu),aes(color="line2"))+ggtitle("Density Curves of Mixture Model Plotted on Histogram of\n Inferred Duplication Times Before Treeinform") + scale_color_manual("Components of Mixture Model", labels=c('line1' = expression("Component 1, " * pi[1]*Gamma(x, alpha, beta)), 'line2' = expression("Component 2, "*pi[2]*f(x,1,lambda,mu))), values=c("#FF000080", "blue")) + xlab("Duplication Times") + ylab("Density") + theme_classic() + theme(legend.position = c(0.8, 0.6))
```

## Validating the effectiveness of treeinform

```{r, fused_percentage, echo=FALSE, fig.cap='The percentage of reassigned tips is plotted above on a log scale. The original assembly had 315,041 genes, with at most 23,396 possible candidates (7.43% of genes) for reassignment. The default threshold for treeinform is highlighted in blue. This threshold value is robust over a wide range from 0.02 down several orders of magnitude.'}
orig_assembly = 315041
t=1:10 # original thresholds were 5000*10^(-t)
threshold = 5000*10^(-t)
# numbers taken from slurm output
reassigned = c(23396, 23396, 22792, 13380, 7944, 5560, 5229, 5219, 5092, 0)
newly_created = c(9009, 9009, 9028, 6006, 3663, 2539, 2381, 2376, 2393, 0)
revised_assembly = c(300654, 300654, 301277, 307667, 310760, 312020, 312193, 312198, 312342, 315041)
fused.df <- data.frame(threshold,reassigned, newly_created, revised_assembly)

# additional thresholds to fill out plot: 0.01, 0.025, 0.035, 0.15, 0.25, 0.35, 1.5, 2.5, 3.5
threshold_add = c(0.01, 0.035, 0.15, 0.25, 0.35, 1.5, 2.5, 3.5, 0.02)
reassigned_add = c(6162, 7429, 9781, 11090, 12123, 18216, 20426, 21808, 6805)
newly_created_add = c(2828, 3424, 4480, 5040, 5481, 7842, 8542, 8895, 3131)
revised_add = c(311707, 311036, 309740, 308991, 308399, 304667, 303157, 302128, 311367)
fused.df <- rbind(fused.df, data.frame(threshold=threshold_add, reassigned=reassigned_add, newly_created=newly_created_add, revised_assembly=revised_add))
fused.df.percents <- transmute(fused.df, threshold, reassigned=reassigned/315041)

# coloring for threshold selection & mixture model selection
grp <- c(rep(1, 18), 2)
fused.df.percents <- cbind(fused.df.percents, grp)

ggplot(fused.df.percents, aes(threshold, reassigned)) + geom_jitter(aes(colour=grp)) + scale_x_log10() + ggtitle("Percentage of reassigned genes vs threshold") + xlab("Threshold") + ylab("Percentage") + theme_classic() + theme(legend.position="none")
```

In order to validate that treeinform improves the accuracy of assigning transcripts to genes under the specified threshold, we performed two analyses. First, we plotted the percentage of reassigned genes at different thresholds to assess the performance of the default threshold value of 0.02 (Supplementary Figure 3). Below the default value, the percentage of reassigned genes begins to plateau, while above the default value the percentage of reassigned genes increases very quickly, increasing the likelihood of treeinform to reassign transcripts from different genes to the same gene in addition to reassign transcripts from the same gene together.

Second, we compared the density of duplication times under the model provided for Component 2 of the mixture model to the distribution of estimated duplication times for gene trees from Agalma1.0 before treeinform, and gene trees from Agalma1.0 after treeinform under 3 different thresholds: 50, 0.05, and the default value 0.02 (Supplementary Figure 4). We again fitted chronograms with the same Siphonophora species tree onto all gene trees from Agalma1.0 and filtered out those gene trees with time of origin greater than 1, so that duplication times were comparable between trees. Visually, the analyses with the 0.02 threshold comes closest to the theoretical.

```{r, fig3b, echo=FALSE, warnings=FALSE, fig.cap="Density from theoretical and the empirical density under the 3 different thresholds. It appears that 0.02 looks the closest to the theoretical density."}
dt <- c(dt_before, threshold_mix, threshold_2, threshold_5)
l1 = length(dt_before)
l2 = length(threshold_mix)
l3 = length(threshold_2)
l4 = length(threshold_5)
Threshold <- rep(NA, l1+l2+l3+l4)
Threshold[1:l1] <- "Before"
Threshold[l1+1:l2] <- "0.02"
Threshold[l1+l2+1:l3] <- "50"
Threshold[l1+l2+l3+1:l4] <- "0.05"
data = data.frame(dt, Threshold)
f = function(x) dup_pdf(x, 1, lambda, mu)
ggplot(data, aes(dt)) + geom_density(aes(group=Threshold, color=Threshold), bw=0.01) + stat_function(fun=f) + ggtitle("Density of inferred and theoretical duplication times\nunder different treeinform thresholds") + xlab("Duplication Times") + ylab("Density") + theme_classic() + theme(legend.position = c(0.8, 0.6)) + geom_hline(yintercept=0, color="white") + geom_vline(xintercept=0, color="white")
```

Additionally, we computed the Kullback-Leibler distance [@kullback1951] between the distributions of duplication times under different thresholds and the theoretical distribution of duplication times (Table 2). Kullback-Leibler distance, otherwise known as relative entropy, measures the distance between two distributions. The KL distance between the distribution of duplication times after running treeinform with the default threshold value of 0.02 come closest to the theoretical distribution as compared to both threshold levels below and above the default value. This indicates that treeinform produces more accurate gene trees with appropriate threshold selection.

```{r, kl, echo=FALSE, fig.cap=''}
z.pre <- rep(NA, 10000)
u <- runif(10000)
theoretical = function(x, u) dup_cdf_sampler(x, 1, lambda, mu, u)
my.uniroot <- function(x) uniroot(theoretical, c(0, 1), u=x)$root
r <- vapply(u, my.uniroot, numeric(1))

d_theo <- discretize(r, numBins=100)
d_before <- discretize(dt_before, numBins=100)
d_mix <- discretize(threshold_mix, numBins=100)
d_2 <- discretize(threshold_2, numBins=100)
d_5 <- discretize(threshold_5, numBins=100)
d_6 <- discretize(threshold_6, numBins=100)
d_8 <- discretize(threshold_8, numBins=100)
kl_dist <- c(KL.empirical(d_before, d_theo), KL.empirical(d_2, d_theo), KL.empirical(d_5, d_theo), KL.empirical(d_mix, d_theo), KL.empirical(d_6, d_theo), KL.empirical(d_8, d_theo))

kl <- data.frame("KL Distance" = kl_dist)
rownames(kl) <- c("Before", "50", "0.05", "0.02", "0.005", "5e-05")
kable(kl, format='pandoc', caption='Kullback-Leibler distances between duplication times after running treeinform with different thresholds and theoretical duplication times.')
```

## Software versions

This manuscript was computed on `r format( Sys.time(), "%a %b %d %X %Y" )` with the following R package versions.

```{r session_summary, echo=FALSE, comment=NA}
	sessionInfo()
```

\pagebreak


## References